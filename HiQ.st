SimpleSwitchMorph subclass: #Cell	instanceVariableNames: 'mouseAction'	classVariableNames: ''	poolDictionaries: ''	category: 'HiQ-DL'!!Cell methodsFor: 'initialization' stamp: 'DL 10/1/2014 16:54'!handlesMouseDown: anEvent    ^false! !!Cell methodsFor: 'initialization' stamp: 'DL 10/1/2014 13:37'!initialize  super initialize.  self label:''.  self borderWidth: 2.  bounds := 0@0 corner: 80@80.  offColor := Color paleYellow.  onColor := Color paleBlue darker.  self useSquareCorners.  self turnOff.! !BorderedMorph subclass: #Game	instanceVariableNames: 'pegs isActive totalPegs'	classVariableNames: ''	poolDictionaries: ''	category: 'HiQ-DL'!!Game methodsFor: 'initialization' stamp: 'DL 9/30/2014 21:45'!cellsPerSide   ^7! !!Game methodsFor: 'initialization' stamp: 'DL 10/2/2014 10:26'!initialize	| sampleCell width height n|	super initialize.	n := self cellsPerSide.	sampleCell := Cell new.	width := sampleCell width.	height := sampleCell height.      isActive := 0.      totalPegs := 32.	self		bounds: (5 @ 5 extent: width * n @ (height * n) + (2 * self borderWidth)).	pegs := Matrix				new: n				tabulate: [:i :j | self newCellAt: i at: j].! !!Game methodsFor: 'initialization' stamp: 'DL 10/1/2014 17:49'!newCellAt: i at: j"Create a cell for position (i,j) and add it to my on-screenrepresentation at the appropriate screen position. Answer the new cell"|hash c p origin|c := Cell new.origin := self innerBounds origin.self addMorph: c.c position: ((i - 1) * c width) @ ((j - 1) * c height) + origin.hash:= #(1 2 6 7).((hash includes: i) & (hash includes: j)) ifTrue: []ifFalse: [   ((i = 4) & (j = 4))   ifTrue:[   p := Peg new.   p setDead.    self addMorph: p.   p position: ((i - 1) * c width + 20) @ ((j - 1) * c height + 20) + origin.   p mouseAction: [self handlePegClickAt: i at: j].   ^p   ]   ifFalse: [   p := Peg new.   self addMorph: p.   p position: ((i - 1) * c width + 20) @ ((j - 1) * c height + 20) + origin.   p mouseAction: [self handlePegClickAt: i at: j].   ^p   ].].! !!Game methodsFor: 'logic' stamp: 'DL 10/1/2014 17:23'!getActive   ^isActive.! !!Game methodsFor: 'logic' stamp: 'DL 10/2/2014 12:06'!handlePegClickAt: i at: j   isActive = 0   ifTrue: [      "Check if peg is alive and set it to active peg"      (pegs at: i at: j) getState = 0      ifTrue: [         (pegs at: i at: j) setActive.         isActive := 1.      ].   ]   ifFalse: [     "Case where a left move to jump a piece is made"     (i < 6)     ifTrue: [        (( (j < 3) | (j > 5) ) & (i > 3))        ifFalse: [              ((pegs at: i + 1 at: j) getState = 0) & ((pegs at: i + 2 at: j) getState = 1) & ((pegs at: i at: j) getState = 2)           ifTrue: [                  totalPegs := totalPegs - 1.                  ((pegs at: i + 1 at: j) setDead).                   ((pegs at: i + 2 at: j) setDead).                   ((pegs at: i at: j) setInactive).                   isActive := 0.           ].        ].     ].     "Case where a right move to jump a piece is made"          i > 2     ifTrue: [        (( (j < 3) | (j > 5)) & (i < 5))        ifFalse: [           ((pegs at: i - 1 at: j) getState = 0) & ((pegs at: i - 2 at: j) getState = 1) & ((pegs at: i at: j) getState = 2)           ifTrue: [                  totalPegs := totalPegs - 1.                  ((pegs at: i - 1 at: j) setDead).                   ((pegs at: i - 2 at: j) setDead).                   ((pegs at: i at: j) setInactive).                   isActive := 0.           ].        ].     ].     "Case where a down move is made to jump a piece"     j < 6     ifTrue: [        (( (i < 3) | (i > 5)) & (j > 3))        ifFalse: [           ((pegs at: i at: j + 1) getState = 0) & ((pegs at: i at: j + 2) getState = 1) & ((pegs at: i at: j) getState = 2)           ifTrue: [                  totalPegs := totalPegs - 1.                  ((pegs at: i at: j + 1) setDead).                   ((pegs at: i at: j + 2) setDead).                   ((pegs at: i at: j) setInactive).                   isActive := 0.           ].        ].     ].     "Case where an up move is made to jump a piece"     j > 2     ifTrue: [        (( (i < 3) | (i > 5)) & (j < 5))        ifFalse: [           ((pegs at: i at: j - 1) getState = 0) & ((pegs at: i at: j - 2) getState = 1) & ((pegs at: i at: j) getState = 2)           ifTrue: [                  totalPegs := totalPegs - 1.                  ((pegs at: i at: j - 1) setDead).                   ((pegs at: i at: j - 2) setDead).                   ((pegs at: i at: j) setInactive).                   isActive := 0.           ].        ].     ].     "If user selects activated peg, select it"      ((pegs at: i at: j) getState = 1)     ifTrue: [        ((pegs at: i at: j) setInactive).         isActive := 0.     ].     "TODO: Implement moves left check - (pegs anySatisfy: [ :peg | self validMoveCheck])"         "Couldn't figure out text morphs, so for now this is the placeholder"         totalPegs > 1         ifTrue: [            Transcript show: 'The total pegs left is: '.            Transcript show: totalPegs.             Transcript cr.         ]         ifFalse: [            Transcript show: 'You win!!!!!!!!!!!!!!!!'.            Transcript cr.         ].     ].   self changed.! !!Game methodsFor: 'logic' stamp: 'DL 10/2/2014 11:00'!validMoveCheckAt: i at: j     "Case where a left move to jump a piece is made"     (i < 6)     ifTrue: [        (( (j < 3) | (j > 5) ) & (i > 3))        ifFalse: [              ((pegs at: i + 1 at: j) getState = 0) & ((pegs at: i + 2 at: j) getState = 1) & ((pegs at: i at: j) getState = 2)           ifTrue: [              ^true.           ].        ].     ].     "Case where a right move to jump a piece is made"          i > 2     ifTrue: [        (( (j < 3) | (j > 5)) & (i < 5))        ifFalse: [           ((pegs at: i - 1 at: j) getState = 0) & ((pegs at: i - 2 at: j) getState = 1) & ((pegs at: i at: j) getState = 2)           ifTrue: [              ^true.           ].        ].     ].     "Case where a down move is made to jump a piece"     j < 6     ifTrue: [        (( (i < 3) | (i > 5)) & (j > 3))        ifFalse: [           ((pegs at: i at: j + 1) getState = 0) & ((pegs at: i at: j + 2) getState = 1) & ((pegs at: i at: j) getState = 2)           ifTrue: [                  ^true.           ].        ].     ].     "Case where an up move is made to jump a piece"     j > 2     ifTrue: [        (( (i < 3) | (i > 5)) & (j < 5))        ifFalse: [           ((pegs at: i at: j - 1) getState = 0) & ((pegs at: i at: j - 2) getState = 1) & ((pegs at: i at: j) getState = 2)           ifTrue: [                  ^true.           ].        ].     ].     ^false! !CircleMorph subclass: #Peg	instanceVariableNames: 'state mouseAction isActive'	classVariableNames: ''	poolDictionaries: ''	category: 'HiQ-DL'!!Peg methodsFor: 'accessing' stamp: 'DL 10/1/2014 20:57'!getState    ^state.! !!Peg methodsFor: 'accessing' stamp: 'DL 10/1/2014 17:39'!setActive   state := 1.   color := Color red.! !!Peg methodsFor: 'accessing' stamp: 'DL 10/1/2014 17:49'!setDead   state := 2.   color := Color white! !!Peg methodsFor: 'accessing' stamp: 'DL 10/1/2014 22:35'!setInactive   state := 0.   color := Color black.! !!Peg methodsFor: 'event handling' stamp: 'DL 10/1/2014 16:50'!handlesMouseDown: anEvent    ^true! !!Peg methodsFor: 'event handling' stamp: 'DL 10/1/2014 14:58'!handlesMouseUp: event  ^false.! !!Peg methodsFor: 'event handling' stamp: 'DL 10/1/2014 17:32'!mouseAction: aBlock   ^mouseAction := aBlock! !!Peg methodsFor: 'event handling' stamp: 'DL 10/1/2014 17:33'!mouseDown: evt   mouseAction value! !!Peg methodsFor: 'parts bin' stamp: 'DL 10/1/2014 16:35'!initialize  super initialize.  bounds := 0@0 corner: 40@40.  color := Color black.  state := 0.! !